# 虚拟化

云计算1.0时代以虚拟化为主，并在此基础上进一步发展，因此虚拟化也成为云计算的入门技术，本章重点介绍计算虚拟化的架构及相关技术。虚拟化一定是软件实现的技术，是通过软件将物理资源转变为虚拟化资源（也叫逻辑资源）。虚拟化技术本身存在多种分类，对不同类型的虚拟化技术进行粗浅的分析可以的出一个概论，虚拟化具备其专有能力，*通过软件将一个物理设备变为多个虚拟设备*，虽然可以虚拟出多个设备，但实际性能还是受到物理设备性能的限制。*只有将一个物理设备的资源通过切片发布给多个用户使用才能够实现资源的复用*，提高物理设备的利用率，同时多个虚拟资源之间的生命周期相互独立

大分小，即将一个设备变为多个设备，是虚拟化的一种形态。同时虚拟化还具备另一种形态，小聚大，即通过软件技术将多个设备聚合成一个强大的逻辑设备

# 计算虚拟化

一个服务器按纵向结构可以大致分为三个平面：硬件、OS、Application。OS与硬件紧密耦合并通过Driver驱动不同的硬件资源，Application与OS耦合并通过OS提供的API接口执行系统调用，用以驱动硬件资源，用户最终是在OS上安装并使用Application。在本小节中主要探讨计算资源的虚拟化，硬件组件中CPU、内存、I/O属于计算资源

## x86 CPU的保护环

![X86_CPU的保护环](file:///${DB}/image/RH318/X86_CPU%E7%9A%84%E4%BF%9D%E6%8A%A4%E7%8E%AF.png)

- Ring0：内核空间，特权级别，是OS/Driver的工作空间，直接驱动硬件 - 特权指令
- Ring3：用户空间，非特权级别，是App的工作空间，用户向App发起请求，App调用OS的API接口 - 用户指令

所谓的纵向结构分层实际上就是x86 CPU的保护环机制，也就是**计算机特权级别**。X86操作系统设计之初是直接在硬件上运行，它认为自己会占用计算机的所有硬件，X86提供了4个特权运行级别提供给操作系统和应用程序访问，运行级别也被称为Ring环，环是指CPU的运行级别。从`Ring 0~Ring 3`权限级别逐渐递减，就X86架构而言，操作系统或内核需要访问硬件、内存，因此它的代码要运行在最高级别`Ring 0`上，这样它就可以使用特权指令，包括中断、修改页表、访问设备等；应用程序的代码运行在最低级别`Ring 3`上，它不能直接做受限制的操作，如果应用程序需要执行受限制的操作时，例如访问硬盘读写文件，就需要执行系统调用或系统函数，执行系统调用时CPU的运行级别就会从`Ring 3`切换到`Ring 0`，并且跳转到系统调用的相应的代码中，由内核来完成硬件设备的访问，完成访问之后再由`Ring 0`返回给`Ring 3`，这个过程称之为用户态和内核态的切换。保护环的分层存在诸多优势

1、分层则意味着不同环对应着不同的职能，开发者可以仅针对具体的环开发相应层级的软件，改变一个环的软件不会影响到其他环

2、不同环对硬件的操作权限级别存在差异，越靠近硬件的环就越接近硬件的原始状态，所需的指令愈加具体和复杂，普通用户没有能力完成如此困难的操作，一旦对硬件的操作出现失误，可能会直接造成系统的崩溃，因此用户态无法直接操作硬件，而是需要通过内核来完成对硬件资源的安全的调用

综上，切忌不可通过App直接调用硬件，App也无法直接调用硬件，如果App通过特殊的指令直接去调用硬件，也就是在用户态出现了特权指令，OS会产生Trap将此指令拦截并捕捉，认为此操作是异常

## 系统虚拟化

![计算虚拟化概念](file:///${DB}/image/HCIA/%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E5%BF%B5.png)

在传统HostOS架构中，应用（app）与OS紧密耦合，OS与硬件紧密耦合，所有与外网通信的**指令流/数据流**都由App拷贝到OS，然后由OS拷贝到硬件（硬盘）中，最后将硬盘中的数据输出到网络。物理设备的内存是划分**区域**的，无论是App或OS都有自己专用的区域，所谓的要与外网通信的数据，实际上就是用户在使用App的过程中产生的指令流/数据流，由App拷贝到OS的过程，实际上是指的用户态所占用的内存区域的数据拷贝到OS所占用的内存区域

而此时如果能在数据传输的逻辑路径上忽略OS层，转而将数据直接从App层拷贝至硬盘（buffer），这样在HostOS架构中能够缩短数据I/O路径，有效降低时延提高吞吐量，此为**直通技术**。在数据传输的路径上忽略OS层并不是真正的完全忽略OS层，终究还是要通过内核来完成对硬件资源的安全的调用，只是在指令调度的时候减少从App层到OS层的拷贝数据的机会

无论是服务器或PC机，最终能产生价值的都是App，OS或硬件都只是为App提供了其所需的运行环境，不同的App承担不同的业务，不同时刻的业务量的大小是变化不定的，因此不同App对硬件资源的利用率也有高有低。为了尽可能的榨取硬件资源，会在一台服务器上运行多个App，不同App之间的隔离就是通过系统虚拟化技术实现的

在虚拟化OS架构中，传统OS层被*虚拟化OS*取代，*虚拟化OS*直接与硬件耦合，并将物理硬件资源转化为虚拟化资源，为应用层的VM提供虚拟化的硬件资源，VM中的OS与*传统OS架构*中的宿主机OS相同，但在VM中被称为GuestOS。假设GuestOS不知道自身处于用户空间，那么自然其也不知道自身使用的硬件是虚拟化资源，所以GuestOS会像*宿主机OS*一样使用自身的硬件，向自身的硬件发送**特权指令**，而VM的硬件收到特权指令时必然会被*虚拟化OS*捕捉

虚拟化技术就是先将HostOS与硬件解耦（软硬分离），这样HostOS和其上运行的应用可以看作一个整体，然后在硬件上再添加一个虚拟化OS层，将多个HostOS放置在一个虚拟化OS上运行，虚拟化OS为上层的HostOS提供虚拟化资源，虚拟化OS实现了上层多个HostOS之间的隔离，并使HostOS在不知情的情况下调用虚拟化硬件来达到物理资源的复用。虚拟化OS也被称为hypervisor或VMM（Virtual Machine Monitor），常见的虚拟化OS有ESXi，XEN等

## 计算虚拟化的分类

![计算虚拟化的分类](file:///${DB}/image/HCIA/%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%88%86%E7%B1%BB.png)

- Ⅰ型虚拟化，也称为裸金属型虚拟化。在硬件上运行一个VMM，VM直接运行在VMM层上
- Ⅱ型虚拟化，也称为宿主型虚拟化。在硬件上有一个宿主机OS，在HostOS上运行一个VMM应用，VMM应用上再运行VM

从架构上来看，Ⅰ型虚拟化比Ⅱ型虚拟化的数据传输路径要短，数据经过的软件层更少，意味着Ⅰ型虚拟化的性能更强；KVM属于Ⅰ型虚拟化

## 虚拟化的特点

1. **分区**：为了能够在一台物理设备上运行多个VM，必须通过软件（VMM）的方式将硬件资源切分，然后为每一个VM提供一套虚拟化的硬件资源；VM在对虚拟硬件资源执行调用时，自然就会被VMM接收并拦截，再由VMM将不同VM的调用请求排序、调用硬件资源。VMM需要具备这种调用分配功能，以实现不同VM复用同一台硬件服务器的资源
2. **隔离**：对虚拟机而言，多个VM之间互相不感知，每个VM只与VMM层发生调用关系；同时VMM作为虚拟化OS，它也应该主动的保障不同VM之间的资源隔离，不同的VM有各自的资源配额、不同VM之间互不影响，各自的生命周期也不相同。资源的隔离还在一定程度上起到了一些安全性作用
3. **封装**：虚拟化OS一定具备其自己的文件系统，在虚拟化OS上创建的每一个VM在关机后，它就是虚拟化OS文件系统上的一个文件，而虚拟化OS又最大化的解决了不同硬件之间的兼容问题，所以在VMM层上的VM，能够非常便捷的在不同的硬件平台之间进行**迁移**
4. **独立**：由于虚拟化OS的出现，GuestOS与硬件解耦，将每个VM作为一个文件来看，每一个VM都是独立存在的，可以在多个主机之间迁移

**资源种类**

1. 计算资源 -> **计算虚拟化** -> CPU、内存、I/O，计算资源主要以CPU、内存为主，I/O资源也属于计算资源，但I/O资源与计算资源、网络资源、存储资源三者都存在关联，例如网卡、硬盘分别于网络资源、存储资源相关
2. 网络资源 -> **网络虚拟化**
3. 存储资源 -> **存储虚拟化**

### CPU虚拟化

用户态与内核态之间的切换动作解决了X86 CPU在分别处理应用软件和操作系统的高级别应用操作的问题，到虚拟化技术的时候面临一个难点，Guest OS和Host OS都要抢占`Ring 0`运行级别，在这种场景下，产生了3种方案用于解决Gust OS和Host OS分别抢占`Ring 0`的问题

1. **完全虚拟化**

    VMM为运行在其上的VM提供虚拟化CPU资源，全虚拟化场景下GuestOS是完全不知道自身运行在vCPU之上的，所以GuestOS任然会向CPU发送特权指令，而整个VM运行在用户态，此时VM向CPU发送的特权指令必然会被hypervisor捕捉，hypervisor捕捉异常指令后将其翻译，然后再交给CPU（此为上下文切换）这种方式被称为异常捕捉。

    但是在用户空间有一些指令，它不是特权指令，但又可以对硬件进行操作，这被称为敏感指令，因为敏感指令不会被VMM捕捉所以异常捕捉的方式现在已经不再适用，转而使用二进制翻译（Binary Translation）技术解决完全虚拟化场景下的敏感指令的捕捉翻译行为。VM的GuestOS的代码一定会保存在VM所占用的物理内存的某一区域中，此时让VMM直接对VM占用的内存中的代码进行扫描，直接找到VM发出的敏感指令进行翻译，这就是二进制翻译技术。二进制翻译比较占用CPU资源，导致性能较弱

    特权指令被包含在敏感指令集中，特权指令是敏感指令，但敏感指令不一定是特权指令

2. **半虚拟化**

    在半虚拟化场景中，会对GuestOS内核的代码进行部分修改（安装插件），让VM知道自身处于VMM之上，所以VM就不会再直接向CPU发送特权指令或敏感指令，而是将原本要发给CPU的指令，转而向VMM的一个特定的中断发起指令，这个行为被称为Hypercall中断，VMM收到hypercall中断进行翻译即可。因为需要对GuestOS内核代码进行修改，所以用于半虚拟化场景中的GuestOS大多为开源操作系统

3. **硬件辅助虚拟化**

    无论是全虚拟化或者半虚拟化，都是VM与VMM之间进行指令的调度和上下文的切换，随着虚拟化技术的发展，Intel和AMD为各自的CPU分别推出了Intel VT和AMD-V技术，在X86架构上增加了对虚拟化技术的支持，也因此增加了一种新的虚拟化解决方案：硬件辅助的全虚拟化（Full Virtualization with Hardware Assist）

    硬件辅助虚拟化直接在硬件层面就支持虚拟化，减少或者直接使VMM不再参与指令的调度，这样VM的指令就可以直达CPU，VMM在VM与CPU之间只起到透传的作用，这种方式极大的提升了性能。硬件上支持虚拟化技术的CPU能够自主识别用户空间和内核空间，且该类型CPU有两种工作模式：**root mode / non-root mode**，根模式下处理VMM内核发送过来的特权指令，而非根模式下处理VM发送过来的用户指令，CPU在两种不同的模式之间进行切换，执行VMM或VM的指令以保证主机安全性，VM向CPU发送特权指令时，CPU会切换到根模式下执行

**三种方案对比**

| 虚拟化程度 | 性能 | 特征 |
| :-: | :-: | :-: |
| 全虚拟化 | 低 | 纯软件的虚拟化，GuestOS对硬件完全无感知 |
| 半虚拟化 | 中 | 纯软件的虚拟化，GuestOS部分知道自身处于虚拟化环境 |
| 硬件辅助的虚拟化 | 高 | 知道自身处于虚拟化环境 |

### 内存虚拟化

**传统HostOS内存映射**

![物理内存页表](file:///${DB}/image/HCIA/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E9%A1%B5%E8%A1%A8.png)

传统HostOS主机上的每个应用程序都有自己的内存空间，它们使用的内存地址都是**逻辑地址**，且这个逻辑地址也是一个**连续的不中断的**相对地址，地址范围是0到无穷大。在物理内存中，每个应用程序有自己的内存页，而主机分配给应用程序的内存页不可能是连续的，所以在HostOS上要维持一个页表，这个页表中记录了**应用程序的逻辑地址**与**主机内存的物理地址**的对应关系，HostOS通过页表将应用程序使用的连续的内存空间映射到其占用的不连续的物理内存页

物理内存是分页的，每个应用程序有自己的内存页。应用程序所使用的内存地址必须是连续不中断的地址空间，但由于内存的读写变化非常快，所以物理内存页几乎不可能提供连续不中断的内存页，因此需要页表来维持逻辑内存地址与物理内存地址之间的映射关系。页表本身也只是内存中维持的一种数据结构

有些资料将主机内存的物理地址称为MA（Machine Address）/PA（Physical Address）/HPA（Host Physical Addr）

**虚拟化OS内存映射**

![VMM内存页表](file:///${DB}/image/HCIA/VMM%E5%86%85%E5%AD%98%E9%A1%B5%E8%A1%A8.png)

虚拟化场景下由于VM的存在，不能只分为逻辑内存地址和物理内存地址两个维度。VM上的APP仍使用逻辑内存地址，GeustOS原本要具备物理内存地址，并通过页表实现逻辑地址与物理地址之间的映射，但虚拟化场景下GuestOS的逻辑位置上移，GuestOS只能得到VMM为其分配的虚拟内存资源，因此虚拟化场景下的GuestOS维护的页表会记录逻辑内存地址与虚拟内存地址的映射关系

虚拟化场景与HostOS场景的内存映射的运行逻辑类似，只不过虚拟化场景中有**两级页表**，VM中的APP的内存映射首先要经过GuestOS的*一级页表*映射到虚拟内存，虚拟内存在经过VMM的*二级页表*映射到物理内存。VMM的二级页表映射的作用，与传统HostOS内存映射场景下的页表的作用一样，是为了将不连续的物理内存页映射到虚拟内存地址

华为官方对不同层的内存有专用的术语

- HPA - 物理内存
- GPA - 虚拟内存，GuestOS内存
- GLA - 逻辑地址

在硬件辅助虚拟化场景中，查询*二级页表*通过硬件实现，intel使用的是**EPT（Extended Page Table）技术**，AMD使用的是**NPT（Nested Page Tables）技术**。通过软件实现的从虚拟机映射到物理内存的二级页面也叫**影子页表**

### I/O虚拟化

I/O设备泛指Input/Output外部设备，比较常见的用得较多的是图形适配器、网口、存储，除了CPU、内存以外的设备泛指外部设备，也就是I/O设备。I/O虚拟化仍围绕不同虚拟化的程度的实现方式进行探讨，I/O设备能够通过纯软件的全仿真模拟真实硬件，也存在支持虚拟化技术的I/O设备直接从硬件层面就可以直接面向虚拟机，由I/O外设向虚拟机提供虚拟资源，直接接管来自虚拟机的业务指令。如果VM发出的指令会被VMM拦截，这一定是软件虚拟化，而如果VM的指令直接发送到硬件，这一定是硬件辅助虚拟化

硬件虚拟化无需对GuestOS做出任何修改，但仍需要在GuestOS中安装相应物理硬件的驱动Driver；如果使用通过VMM提供的软件的虚拟资源，则只需要安装一个通用的I/O设备驱动，例如网卡常见的E1000适配器，现在的操作系统ISO镜像文件中基本上都自带有这些通用的设备驱动，甚至都不需要手动安装。软件所使用的虚拟资源安装的通用驱动，实际上与物理硬件没有关联，GuestOS也不需要向硬件虚拟化一样安装真实硬件所需要的驱动，一个通用的I/O设备驱动即可，但VMM需要具备真实硬件的驱动

在硬件虚拟化的场景下，VM的指令直通对应的硬件，VMM在中间透传指令；在软件虚拟化场景下，VM的指令会被VMM拦截，硬件无法直接识别VM的指令，因此还需要VMM对VM的指令进行翻译后转交给硬件执行。软件虚拟化场景只需要普通硬件即可，硬件虚拟化场景必须要特殊的支持虚拟化技术的硬件，软件虚拟化的I/O路径长、时延也长，硬件虚拟化的I/O路径短、时延也短

1. **完全虚拟化**

    完全通过软件模拟VM需要的真实硬件，VM对虚拟硬件资源完全无感知，GuestOS会将指令发送给虚拟硬件资源执行，VMM在中间需要拦截、捕捉VM的指令，翻译后转交给具体的硬件执行。使用VM时不需要对GuestOS做出任何修改，可移植性非常好，但VMM过度参与指令的处理，导致性能差

2. **半虚拟化**

    目前硬件辅助虚拟化技术还不成熟，支持硬件辅助虚拟化的I/O设备不多或造价成本高昂，现在的虚拟化解决方案中I/O设备更多的会使用全虚或半虚。全虚的劣势在于其性能较差、用户体验差，为了尽可能提升用户体验而产生了半虚拟化解决方案，不同的虚拟化架构的半虚拟化方案各有差异，半虚拟化是伴随着Xen虚拟化架构而出现的，KVM虚拟化架构也具备其自己的半虚拟化方案，学习半虚拟化方案需要针对具体的虚拟化架构分析，然而无论是Xen架构或KVM架构，两者虽然具体的半虚拟化方案存在差异，但解决思路上都使用了“前端驱动+后端驱动”的方式，以Xen架构的半虚拟化为例

    Xen架构中的虚拟机被又称为*Domain*，Domain是存在编号的，在Xen架构的I/O虚拟化的半虚拟化场景中，Xen提供的VM中有一个特殊的系统VM被称为“Domain 0”，此VM不面向用户，而是属于虚拟化环境中的一部分，在Domain 0中存放了硬件设备的**原生驱动**，并向其他VM提供系统功能，无论是否存在用户VM，Domain 0都是存在的，且Domain 0会作为第一台启动的VM。这种设计模式将原生驱动模块化了，并将其放在一个安全的空间，使原生驱动与VMM分离，这是一种安全性的隔离，避免因为原生驱动的崩溃导致虚拟化的崩溃。也由于Xen架构将物理硬件设备的原生驱动全部存放在Domain 0中，因此VMM本身非常精简，只用于负责CPU、内存等一些必要的虚拟化操作

    全虚与半虚是通过GuestOS是否知晓自身处于虚拟化环境来界定的，半虚需要对GuestOS做出改动，Xen架构的I/O设备半虚拟化需要将I/O外设所对应的Driver一分为二，一部分Driver安装在GuestOS中，也就是Xen架构的前端驱动（Front-end Driver），另一部分Driver安装在Domain 0中，也就是Xen架构的后端驱动（Back-end Driver）。前端驱动是面向用户虚拟机的一部分，后端驱动是属于虚拟化环境的一部分，前端驱动+后端驱动才是一个完整的驱动，因此VM与Domain 0之间就会存在一个通讯过程，VM的指令和数据由前端驱动传递到后端驱动，后端驱动收到来自不同VM的前端驱动传递的数据，会先将不同VM的数据进行排序后，转交给原生驱动执行硬件操作。原生驱动本身是不支持虚拟化的，因此多个VM的数据会复用原生驱动

    Xen架构的半虚拟化方案中，VMM层不再拦截VM的指令，前驱+后驱的架构实现了每个VM的所有I/O指令或数据都通过一条单独的通道通信（前驱/后驱），所以半虚相较全虚性能有所提升，但半虚受限于架构，它要将驱动分离为前后两端，需要修改GuestOS的驱动程序

3. **硬件辅助虚拟化**

    IO-trough：VMM实现I/O透传，“直接分配”给虚拟机物理设备，例如直接为虚拟机分配一块硬盘或网卡。这种直接分配指的是I/O硬件设备自身必须提供多个虚拟硬件资源，将自身的虚拟硬件映射给多个虚拟机使用，以此实现I/O设备可以直接处理虚拟机的指令和数据。这种方式需要I/O设备具备I/O透传技术，在Xen架构下由Domain 0进行资源分配，但虚拟机可以不经过Domain 0而直接访问、使用I/O设备